// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v6.0", FrameworkDisplayName = "")]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("fib")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("fib")]
[assembly: System.Reflection.AssemblyTitleAttribute("fib")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Files Bundler")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("Files Bundler")]
[assembly: System.Reflection.AssemblyTitleAttribute("Files Bundler")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
﻿

using System;

namespace Files_Bundler
{
    public static class Functions
    {
        public static List<string> DirSearch(string sDir)
        {
            List<string> files = new List<String>();
            try
            {
                foreach (string f in Directory.GetFiles(sDir))
                {
                    files.Add(f);
                }
                foreach (string d in Directory.GetDirectories(sDir))
                {
                    files.AddRange(DirSearch(d));
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            return files;
        }
        public static List<string> GetListOfProgrammingLanguages()
        {
            return new List<string> { "c", "c++", "c#", "java", "python", "javascript", "js", "ruby", "swift", "kotlin", "rust", "go", "php", "perl", "typescript", "dart", "r", "matlab", "fortran", "cobol", "ada", "lisp", "scheme", "prolog", "haskell", "erlang", "groovy", "scala", "ruby", "html", "css", "sql", "assembly language", "vhdl", "verilog", "scratch", "blockly" };
        }
        public static List<string> removeUnnecessaryLangs(List<string> filesNames)
        {
            List<string> validLanguages = GetListOfProgrammingLanguages();
            List<string> filteredFileNames = new List<string>();
            foreach (string fileName in filesNames)
            {
                string language = GetLanguageFromExtension(fileName);
                if (validLanguages.Contains(language))
                {
                    filteredFileNames.Add(fileName);
                }
            }
            return filteredFileNames;
        }
        public static string GetLanguageFromExtension(string fileName)
        {
            string extension = Path.GetExtension(fileName).TrimStart('.').ToLower();
            Dictionary<string, string> extensionToLanguage = new Dictionary<string, string>
            {
                { "c", "c" },
                { "cpp", "c++" },
                { "cs", "c#" },
                { "json", "json" },
                { "java", "java" },
                { "py", "python" },
                { "js", "javascript" },
                { "rb", "ruby" },
                { "swift", "swift" },
                { "kt", "kotlin" },
                { "rs", "rust" },
                { "go", "go" },
                { "php", "php" },
                { "pl", "perl" },
                { "ts", "typescript" },
                { "dart", "dart" },
                { "r", "r" },
                { "m", "matlab" },
                { "f90", "fortran" },
                { "cob", "cobol" },
                { "ada", "ada" },
                { "lisp", "lisp" },
                { "scm", "scheme" },
                { "pro", "prolog" },
                { "hs", "haskell" },
                { "erl", "erlang" },
                { "groovy", "groovy" },
                { "scala", "scala" },
                { "html", "html" },
                { "css", "css" },
                { "sql", "sql" },
                { "asm", "assembly" },
                { "vhd", "vhdl" },
                { "v", "verilog" },
                { "sb3", "scratch" },
                { "blk", "blockly" }
            };
            if (extensionToLanguage.TryGetValue(extension, out string language))
            {
                return language;
            }
            else
            {
                return "Unknown";
            }
        }

        static public bool checkAllGivenLangsValidation(List<string> givenLangs, List<string> validProgrammingLanguages)
        {

            foreach (var lang in givenLangs)
            {
                bool isValidLang = false;
                foreach (var vLang in validProgrammingLanguages)
                {
                    if (lang.ToLower() == vLang)
                    {
                        isValidLang = true;
                    }
                }
                if (isValidLang == false)
                {
                    return false;
                }
            }
            return true;
        }
        public static List<string> sortByProgrammingLangs(List<string> listToSort)
        {
            var sortedFiles = listToSort
                .OrderBy(name => Path.GetExtension(name)) 
                .ToList();

            return sortedFiles;
        }
        public static bool RemoveEmptyLinesFromFile(string filePath)
        {
            try
            {
                string content = File.ReadAllText(filePath);
                string[] lines = content.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);
                string nonEmptyContent = string.Join(Environment.NewLine, lines.Where(line => !string.IsNullOrWhiteSpace(line)));
                File.WriteAllText(filePath, nonEmptyContent);
                return true;
            }
            catch (IOException e)
            {
                Console.WriteLine("An error occurred while processing the file: " + e.Message);
                return false;
            }
        }

        public static bool createRspFile(FileInfo output, string language, bool note, string author, bool sort, bool remove, FileInfo responseFile)
        {
            var responseFileContents = $"fib bundle " +
                $"--output {output.FullName} " +
                $"--language {language} " +
                (note ? "--note " : string.Empty) +
                (!string.IsNullOrEmpty(author) ? $"--author {author} " : string.Empty) +
                (sort ? "--sort " : string.Empty) +
                (remove ? "--remove-empty-lines " : string.Empty);

            try
            {
                File.WriteAllText(responseFile.FullName, responseFileContents);
                Console.WriteLine($"Response file '{responseFile.FullName}' created successfully.");
                return true;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error creating response file: {ex.Message}");
                return false;
            }
        }

    }
}
﻿using Files_Bundler;
using System.CommandLine;

var rootCommand = new RootCommand("Root command for file bundler CLI");
var bundleCommand = new Command("bundle", "Bundle code files to a single file");
var bundleOutputOption = new Option<FileInfo>("--output", "file path and name");
var bundleNoteOption = new Option<bool>("--note", "Include source code references as comments in the bundled file");
var bundleSortOption = new Option<bool>("--sort", "file path and name"); 
var bundleRemoveOption = new Option<bool>("--remove-empty-lines", "Remove empty lines in the code files");
var bundleAuthorOption = new Option<string>("--author", "file author name");
var bundleLangOption = new Option<string>("--language", "required languages for the bundled output")
{
    IsRequired = true,
};
var bundleCreateRspOption = new Option<FileInfo>("--create-rsp", "create a response file");

bundleLangOption.AddAlias("--l");
bundleOutputOption.AddAlias("--o");
bundleRemoveOption.AddAlias("--r");
bundleNoteOption.AddAlias("--n");
bundleAuthorOption.AddAlias("--a");
bundleSortOption.AddAlias("--s");

bundleCommand.AddOption(bundleOutputOption);
bundleCommand.AddOption(bundleLangOption);
bundleCommand.AddOption(bundleNoteOption);
bundleCommand.AddOption(bundleAuthorOption);
bundleCommand.AddOption(bundleRemoveOption);
bundleCommand.AddOption(bundleSortOption);
bundleCommand.AddOption(bundleCreateRspOption);

bundleCommand.SetHandler((output, langueges, note, author, sort, remove, respFile) =>
{
    try
    {
        List<string> filesNames = Functions.DirSearch(Directory.GetCurrentDirectory());
        filesNames = Functions.removeUnnecessaryLangs(filesNames);
        List<string> requestedFilesList = new List<string>();
        File.Create(output.FullName).Close();
        if(respFile != null)
        {
            bool succeed = Functions.createRspFile(output, langueges, note, author, sort, remove, respFile);
            if (!succeed)
            {
                throw new Exception("Error while creating response file");
            }
            return;
        }
        if (langueges == "all")
        {
            requestedFilesList = filesNames;
        }
        else
        {
            List<string> givenLangs = langueges.Split(' ').ToList();
            List<string> validProgrammingLanguages = Functions.GetListOfProgrammingLanguages();
            bool givenLangsValidation = Functions.checkAllGivenLangsValidation(givenLangs, validProgrammingLanguages);
            if (!givenLangsValidation)
            {
                throw new Exception("ERROR: one or more of the given languages is invalid");
            }
            foreach (var file in filesNames)
            {
                string fileLang = Functions.GetLanguageFromExtension(file);
                bool includeFile = false;
                foreach (var lang in givenLangs)
                {
                    if (fileLang == lang)
                    {
                        includeFile = true;
                    }
                }
                if (includeFile == true)
                {
                    requestedFilesList.Add(file);
                }
            }
        }
        if (sort == true)
        {
            requestedFilesList = Functions.sortByProgrammingLangs(requestedFilesList);
        }
        else
        {
            requestedFilesList = requestedFilesList.OrderBy(name => Path.GetFileName(name)).ToList();
        }
        try
        {
            using (var outputFile = new FileStream(output.FullName, FileMode.Create))
            {
                foreach (string fileLocation in requestedFilesList)
                {
                    using (var inputFile = new FileStream(fileLocation, FileMode.Open))
                    {
                        inputFile.CopyTo(outputFile);
                    }
                }
            }
        }
        catch(Exception ex)
        {
            Console.WriteLine(ex.Message);
        }

        if (remove == true)
        {
            try
            {
                bool success = Functions.RemoveEmptyLinesFromFile(output.FullName);

                if (!success) { 
                    Console.WriteLine("Failed to remove empty lines from the file.");
                }
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message);
            }
        }
        try
        {
            if (author != null)
            {
                using (StreamWriter writer = new StreamWriter(output.FullName, true))
                {
                    writer.WriteLine("\n\n Author: " + author);
                }
            }
            if (note == true)
            {
                using (StreamWriter writer = new StreamWriter(output.FullName, true))
                {
                    writer.WriteLine("\n\n Note:" + Directory.GetCurrentDirectory());
                }
            }
        }
        catch (Exception ex)
        {
            throw new Exception(ex.Message);
        }
    }
    catch (DirectoryNotFoundException ex)
    {
        Console.WriteLine("ERROR: output file path is invalid");
    }
    catch (Exception ex)
    {
        Console.WriteLine("An error occurred: " + ex.Message);
    }
}, bundleOutputOption, bundleLangOption, bundleNoteOption, bundleAuthorOption, bundleSortOption, bundleRemoveOption, bundleCreateRspOption);

rootCommand.AddCommand(bundleCommand);
rootCommand.InvokeAsync(args);


 Author: tamar
